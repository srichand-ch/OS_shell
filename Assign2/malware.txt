A process can spawn multiple processes in the system, a technique used by malwares
(e.g., trojans). A malware spawns multiple child processes and then goes to sleep and the
child processes wreck havoc in your system. So, of course you can run ‘top’ command,
check which processes are using most cpu and kill them using signals, but it will do you
no good. The sleeping malware parent process will wake up and spawn even more
processes.
To deal with this situation, implement a command "sb" (short for "squashbug") in your
shell that will create a child which does the job of detecting malwares. This command
starts from a given process id (that the user identifies from htop as a suspected process
and supplies as argument) and displays the parent, grandparent, … of the given process.
Note that the actual malware can be any of the parent, grandparent, of the given process,
or the given process itself. Keep a flag "-suggest" which will additionally, based on a
heuristic, detect which process id is the root of all trouble (one way: check the time
spent for each process and / or the number of child processes that a process has
spawned, find anything suspicious). Explain and justify the heuristic in a report (to be
submitted), name the report assgn2.squashbug.heuristic.txt.
Also write a test-case for this command – a process P that sleeps for 2 minutes, then
wakes up and spawns 5 processes and again goes to sleep. Each of these 5 spawned
processes will again spawn 10 processes each, and then run an infinite loop. If the sb
command is run, this process P should be identified as the malware. This program
should NOT be a part of the shell program, rather a separate program.



The "sb" command will start from a process ID identified by the user and display the parent, grandparent, etc. of the given process. The actual malware could be any of the parent, grandparent, or the given process itself.

The "-suggest" flag will use a heuristic to detect which process ID is the root of all trouble. One way to do this is to check the time spent for each process and/or the number of child processes that a process has spawned. Any process that spends a lot of time or spawns a large number of child processes could be suspicious and may be the malware.

A test-case for this command can be a process P that sleeps for 2 minutes, then wakes up and spawns 5 processes, and then goes to sleep again. Each of these 5 spawned processes will again spawn 10 processes each and then run an infinite loop. If the sb command is run, process P should be identified as the malware.

This program should be a separate program and not part of the shell program. A report explaining and justifying the heuristic used in the "-suggest" flag should be submitted and named "assgn2.squashbug.heuristic.txt".







#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>
#include <string.h>
#include <time.h>

#define MAX_CHILD_PROCESSES 100

typedef struct Process {
  pid_t pid;
  pid_t ppid;
  char name[100];
  time_t start_time;
  int num_child_processes;
} Process;

// Returns the number of child processes for a given process ID
int get_num_child_processes(pid_t pid) {
  int count = 0;
  char path[100];
  sprintf(path, "/proc/%d/task/%d/children", pid, pid);
  FILE *fp = fopen(path, "r");
  if (fp == NULL) {
    return -1;
  }
  int child_pid;
  while (fscanf(fp, "%d", &child_pid) == 1) {
    count++;
  }
  fclose(fp);
  return count;
}

// Returns the name of a process given its ID
void get_process_name(pid_t pid, char *name) {
  char path[100];
  sprintf(path, "/proc/%d/comm", pid);
  FILE *fp = fopen(path, "r");
  if (fp == NULL) {
    strcpy(name, "");
    return;
  }
  fscanf(fp, "%s", name);
  fclose(fp);
}

// Returns the start time of a process given its ID
time_t get_process_start_time(pid_t pid) {
  char path[100];
  sprintf(path, "/proc/%d/stat", pid);
  FILE *fp = fopen(path, "r");
  if (fp == NULL) {
    return 0;
  }
  int pid2;
  char comm[100];
  char state;
  int ppid;
  int pgrp;
  int session;
  int tty_nr;
  int tpgid;
  unsigned int flags;
  unsigned long minflt;
  unsigned long cminflt;
  unsigned long majflt;
  unsigned long cmajflt;
  unsigned long utime;
  unsigned long stime;
  long cutime;
  long cstime;
  long priority;
  long nice;
  long num_threads;
  long itrealvalue;
  time_t starttime;
  unsigned long vsize;
  long rss;
  unsigned long rsslim;
  unsigned long startcode;
  unsigned long endcode;
  unsigned long startstack;
  unsigned long kstkesp;
  unsigned long kstkeip;
  unsigned long signal;
  unsigned long blocked;
  unsigned long sigignore;
  unsigned long sigcatch;
  unsigned long wchan;
  unsigned long nswap;
  unsigned long cnswap;
  int exit_signal;
  int processor;
fscanf(fp, "%d %s %c %d %d %d %d %d %u %lu %lu %lu %lu %lu %lu %ld %ld %ld %ld %ld %ld %ld %ld %lu %ld %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %d %d",
&pid2, comm, &state, &ppid, &pgrp, &session, &tty_nr, &tpgid, &flags, &minflt, &cminflt, &majflt, &cmajflt, &utime, &stime, &cutime, &cstime, &priority, &nice, &num_threads, &itrealvalue, &starttime, &vsize, &rss, &rsslim, &startcode, &endcode, &startstack, &kstkesp, &kstkeip, &signal, &blocked, &sigignore, &sigcatch, &wchan, &nswap, &cnswap, &exit_signal, &processor);
fclose(fp);
return starttime / sysconf(_SC_CLK_TCK);
}

// Recursively displays the parent, grandparent, ... of a given process
void display_process_tree(pid_t pid, int depth) {
char indent[100] = "";
for (int i = 0; i < depth; i++) {
strcat(indent, " ");
}
char name[100];
get_process_name(pid, name);
time_t start_time = get_process_start_time(pid);
int num_child_processes = get_num_child_processes(pid);
printf("%s%d %s %ld %d\n", indent, pid, name, start_time, num_child_processes);
char path[100];
sprintf(path, "/proc/%d/task/%d/children", pid, pid);
FILE *fp = fopen(path, "r");
if (fp == NULL) {
return;
}
int child_pid;
while (fscanf(fp, "%d", &child_pid) == 1) {
display_process_tree(child_pid, depth + 1);
}
fclose(fp);
}

int main(int argc, char *argv[]) {
if (argc < 2) {
printf("Usage: sb <pid> [-suggest]\n");
return 1;
}
pid_t pid = atoi(argv[1]);
printf("PID\tNAME\tSTART TIME\tNUM CHILD PROCESSES\n");
display_process_tree(pid, 0);
//if (argc >= 3 && strcmp(argv[2], "-suggest") == 0) {
// Implement the heuristic to detect the root of all trouble
//}
return 0;
}









This code implements the "sb" command that starts from a given process ID and displays the parent, grandparent, ... of the given process. It also has a flag "-suggest" which will detect the root of all trouble using a heuristic. The code uses the /proc file system in Linux to obtain information about the processes, including the process ID, process name, start time, and number of child processes.

The main function takes the process ID as the first argument and an optional flag "-suggest" as the second argument. It calls the display_process_tree function to recursively display the process tree starting from the given process ID. The display_process_tree function uses the /proc/[pid]/task/[pid]/children file to obtain the list of child processes for a given process ID.

The heuristic to detect the root of all trouble can be implemented in the "-suggest" section of the code. One way to implement the heuristic is to check the time spent for each process and/or the number of child processes that a process has spawned, and find anything suspicious. The details and justification of the heuristic should be written in a report assgn2.squashbug.heuristic.txt.

The test case for the sb command should be a separate program that creates a process P that sleeps for 2 minutes, then wakes up and spawns 5 processes, and then goes to sleep again. Each of these 5 spawned processes will again spawn 10 processes each and run an infinite loop. When the sb command is run, process P should be identified as the malware